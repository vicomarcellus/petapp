import { createClient } from '@supabase/supabase-js';

/**
 * Serverless функция для выполнения миграций базы данных
 * Vercel Edge Function
 */

export const config = {
  runtime: 'edge',
};

const supabaseUrl = process.env.VITE_SUPABASE_URL || 'https://jweegvbywvixwzcliyzr.supabase.co';
const supabaseServiceKey = process.env.SUPABASE_SERVICE_ROLE_KEY;

export default async function handler(req: Request) {
  // Только POST запросы
  if (req.method !== 'POST') {
    return new Response(JSON.stringify({ error: 'Method not allowed' }), {
      status: 405,
      headers: { 'Content-Type': 'application/json' },
    });
  }

  try {
    // Проверяем наличие service key
    if (!supabaseServiceKey) {
      return new Response(
        JSON.stringify({ 
          error: 'Service key not configured',
          hint: 'Add SUPABASE_SERVICE_ROLE_KEY to environment variables'
        }), 
        {
          status: 500,
          headers: { 'Content-Type': 'application/json' },
        }
      );
    }

    // Создаем клиент с правами администратора
    const supabase = createClient(supabaseUrl, supabaseServiceKey);

    // Получаем токен пользователя из заголовка
    const authHeader = req.headers.get('Authorization');
    if (!authHeader) {
      return new Response(JSON.stringify({ error: 'Unauthorized' }), {
        status: 401,
        headers: { 'Content-Type': 'application/json' },
      });
    }

    // Проверяем авторизацию пользователя
    const token = authHeader.replace('Bearer ', '');
    const { data: { user }, error: authError } = await supabase.auth.getUser(token);

    if (authError || !user) {
      return new Response(JSON.stringify({ error: 'Invalid token' }), {
        status: 401,
        headers: { 'Content-Type': 'application/json' },
      });
    }

    // Выполняем миграцию
    const migrationSQL = `
      -- Создание таблицы diagnoses
      CREATE TABLE IF NOT EXISTS public.diagnoses (
          id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
          user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
          pet_id BIGINT NOT NULL REFERENCES public.pets(id) ON DELETE CASCADE,
          date DATE NOT NULL DEFAULT CURRENT_DATE,
          diagnosis TEXT NOT NULL,
          notes TEXT,
          created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
      );

      -- Создание индекса
      CREATE INDEX IF NOT EXISTS idx_diagnoses_user_pet_date 
        ON public.diagnoses(user_id, pet_id, date);

      -- Включение Row Level Security
      ALTER TABLE public.diagnoses ENABLE ROW LEVEL SECURITY;

      -- Удаление старых политик если есть
      DROP POLICY IF EXISTS "Users can view own diagnoses" ON public.diagnoses;
      DROP POLICY IF EXISTS "Users can insert own diagnoses" ON public.diagnoses;
      DROP POLICY IF EXISTS "Users can update own diagnoses" ON public.diagnoses;
      DROP POLICY IF EXISTS "Users can delete own diagnoses" ON public.diagnoses;

      -- Создание политик доступа
      CREATE POLICY "Users can view own diagnoses" 
          ON public.diagnoses FOR SELECT 
          USING (auth.uid() = user_id);

      CREATE POLICY "Users can insert own diagnoses" 
          ON public.diagnoses FOR INSERT 
          WITH CHECK (auth.uid() = user_id);

      CREATE POLICY "Users can update own diagnoses" 
          ON public.diagnoses FOR UPDATE 
          USING (auth.uid() = user_id);

      CREATE POLICY "Users can delete own diagnoses" 
          ON public.diagnoses FOR DELETE 
          USING (auth.uid() = user_id);
    `;

    // Выполняем SQL через RPC или прямой запрос
    const { error: sqlError } = await supabase.rpc('exec_sql', { sql: migrationSQL });

    if (sqlError) {
      console.error('Migration error:', sqlError);
      return new Response(
        JSON.stringify({ 
          error: 'Migration failed',
          details: sqlError.message,
          hint: 'You may need to run the SQL manually in Supabase Dashboard'
        }), 
        {
          status: 500,
          headers: { 'Content-Type': 'application/json' },
        }
      );
    }

    return new Response(
      JSON.stringify({ 
        success: true,
        message: 'Migration completed successfully'
      }), 
      {
        status: 200,
        headers: { 'Content-Type': 'application/json' },
      }
    );

  } catch (error: any) {
    console.error('Unexpected error:', error);
    return new Response(
      JSON.stringify({ 
        error: 'Internal server error',
        details: error.message
      }), 
      {
        status: 500,
        headers: { 'Content-Type': 'application/json' },
      }
    );
  }
}
